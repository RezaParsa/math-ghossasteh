سوال: ماتریس متناظر با یک رابطه رو از ورودی بگیره و بررسی کنه که این ماتریس آیا خاصیت تقارن و خاصیت پاد تقارن و خاصیت ترایایی دارد یا خیر؟



بخش اول: بررسی تقارن (Symmetry) 🔄
خاصیت تقارن مثل یک آینه عمل می‌کند. اگر از یک نقطه به نقطه دیگر فلش داشته باشیم، از نقطه دوم به نقطه اول هم باید فلش داشته باشیم.

is_symmetric = True: یک پرچم یا "چراغ" به نام is_symmetric درست می‌کنیم و آن را روشن (True) می‌گذاریم. اگر در طول برنامه حتی یک مورد نقض پیدا کنیم، این چراغ را خاموش (False) می‌کنیم.

for x in range(n) و for y in range(n): ما دو حلقه تکرار تو در تو داریم که به هر خانه در جدول (ماتریس) دسترسی پیدا می‌کنند. x برای سطرها و y برای ستون‌ها است.

if matrix[x][y] != matrix[y][x]: اینجا جادوی بررسی اتفاق می‌افتد. کد چک می‌کند که آیا مقدار خانه [x, y] با مقدار خانه [y, x] برابر است؟

is_symmetric = False و break: اگر این دو خانه برابر نبودند (مثلاً یکی ۱ و دیگری ۰ بود)، یعنی خاصیت تقارن نقض شده است. پس چراغ is_symmetric را خاموش می‌کنیم و از حلقه‌ها خارج می‌شویم چون دیگر نیازی به بررسی بقیه خانه‌ها نیست.

در نهایت، با توجه به وضعیت چراغ، نتیجه نهایی را چاپ می‌کنیم.

بخش دوم: بررسی پادتقارن (Antisymmetry) ↔️
خاصیت پادتقارن دقیقاً برعکس تقارن است. اگر از یک نقطه به نقطه دیگر فلش داریم، نباید هیچ فلشی از آن نقطه به نقطه اول داشته باشیم (مگر اینکه هر دو نقطه یکی باشند).

is_antisymmetric = True: یک چراغ دیگر به نام is_antisymmetric روشن می‌کنیم.

if x != y and matrix[x][y] == 1 and matrix[y][x] == 1: این شرط مهم‌ترین بخش است. کد بررسی می‌کند که:

آیا سطر و ستون یکسان نیستند؟ (x != y)

آیا در خانه [x, y] عدد ۱ وجود دارد؟

آیا در خانه [y, x] هم عدد ۱ وجود دارد؟

اگر هر سه شرط درست باشد، یعنی هم فلش از x به y داریم و هم از y به x، در حالی که این دو نقطه یکی نیستند. این یعنی خاصیت پادتقارن نقض شده است.

is_antisymmetric = False و break: در این صورت، چراغ is_antisymmetric را خاموش می‌کنیم و از حلقه‌ها خارج می‌شویم.

بخش سوم: بررسی تراگذری (Transitivity) ➡️➡️➡️
این ویژگی مثل این است که اگر از الف به ب و از ب به ج راهی وجود دارد، یک راه مستقیم از الف به ج هم باید وجود داشته باشد. برای بررسی این ویژگی، از ضرب بولی ماتریس استفاده می‌کنیم.

تابع boolean_multiply:

این تابع یک کار مشخص را انجام می‌دهد: ضرب بولی دو ماتریس. این همان تابعی است که در پروژه‌های قبلی هم دیدیم.

با استفاده از سه حلقه تکرار، خانه‌های ماتریس اول را با خانه‌های ماتریس دوم ترکیب می‌کند و با استفاده از قوانین and و or، نتیجه نهایی را در یک جدول جدید ذخیره می‌کند.

محاسبه R²:

r_squared = boolean_multiply(matrix, matrix): ما ماتریس اصلی را به تابع boolean_multiply می‌دهیم تا آن را در خودش ضرب کند. نتیجه این ضرب، R² است. R² به ما می‌گوید که در دو مرحله از کدام نقاط به کدام نقاط می‌توانیم برسیم.

مقایسه R² و R:

is_transitive = True: یک چراغ به نام is_transitive روشن می‌کنیم.

if r_squared[x][y] == 1 and matrix[x][y] == 0: این شرط جادویی، خاصیت تراگذری را بررسی می‌کند. کد می‌گوید: "اگر در جدول R²، در خانه [x, y] یک ۱ وجود داشت (یعنی می‌توان در دو مرحله از x به y رسید)، اما در جدول اصلی (R)، در همان خانه ۰ بود (یعنی راه یک‌مرحله‌ای وجود نداشت)، پس خاصیت تراگذری نقض شده است."

در این صورت، چراغ is_transitive را خاموش می‌کنیم.