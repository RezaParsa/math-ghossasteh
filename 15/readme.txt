 قدم به قدم 🚶‍♂️
آماده‌سازی:

adjacency_matrix: جدول (ماتریس) اصلی ماست که نشان می‌دهد کدام نقاط به هم وصل هستند.

num_nodes: تعداد نقاط گراف را حساب می‌کند.

reached_nodes: یک جعبه خالی (در قالب یک مجموعه) است که در آن نقاطی را که به آن‌ها سر زده‌ایم، می‌گذاریم. ابتدا فقط نقطه 0 در آن قرار دارد.

queue: یک صف است که نقاطی را که باید در آینده بررسی کنیم، در آن قرار می‌دهیم. ابتدا فقط نقطه 0 در آن است.

حلقه اصلی (کشف نقاط):

while queue:: این حلقه تا زمانی که queue خالی نشده، اجرا می‌شود.

current_node = queue.pop(0): اولین نقطه را از صف برمی‌داریم تا آن را بررسی کنیم.

for neighbor in range(num_nodes):: با یک حلقه دیگر، تمام نقاط دیگر (همسایه‌ها) را بررسی می‌کنیم.

if adjacency_matrix[current_node][neighbor] == 1 and neighbor not in reached_nodes:: این مهم‌ترین شرط است! کد می‌گوید: "اگر بین نقطه فعلی و این همسایه راهی وجود دارد (یعنی مقدار 1 است) و هنوز به این همسایه سر نزده‌ایم..."

reached_nodes.add(neighbor) و queue.append(neighbor): اگر شرط بالا برقرار باشد، همسایه جدید را به جعبه reached_nodes اضافه می‌کنیم و آن را در صف می‌گذاریم تا بعداً همسایه‌های او را هم بررسی کنیم.

نتیجه‌گیری نهایی:

بعد از اینکه حلقه تمام شد، یعنی دیگر راهی برای رفتن به یک نقطه جدید پیدا نکرده‌ایم.

if len(reached_nodes) == num_nodes:: حالا تعداد نقاطی که در جعبه reached_nodes داریم را می‌شماریم. اگر این تعداد با تعداد کل نقاط گراف یکی بود، یعنی از نقطه شروع توانسته‌ایم به همه جا برسیم، پس گراف همبند است.

در غیر این صورت، یعنی به بعضی از نقاط نرسیده‌ایم و گراف همبند نیست.