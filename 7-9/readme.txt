ماتریس اصلی و توابع 📚
matrix = [[1, 0, 0], [1, 1, 0], [0, 1, 1]]: اینجا یک جدول (ماتریس) به عنوان ورودی اصلی تعریف شده. این ماتریس، رابطه ما رو نشون می‌ده.

def reflexive_closure(m): یک تابع یا "ماشین" برای حساب کردن بستار بازتابی ساخته شده.

def symmetric_closure(m): یک "ماشین" برای حساب کردن بستار تقارنی ساخته شده.

def transitive_closure(m): یک "ماشین" برای حساب کردن بستار ترایایی ساخته شده.

حالا به توضیح هر ماشین به صورت جداگانه می‌پردازیم.

۱. بستار بازتابی (Reflexive Closure) 🔄
خاصیت بازتابی یعنی هر نقطه به خودش فلش داشته باشه. در ماتریس، یعنی خانه‌های روی قطر اصلی (مانند [0, 0], [1, 1], [2, 2]) باید حتماً ۱ باشند.

n = len(m): تعداد سطرها (یا ستون‌ها) رو پیدا می‌کنه.

result = [row[:] for row in m]: یک کپی دقیق از ماتریس اصلی می‌سازه تا تغییرات روی اون انجام بشه و به ماتریس اصلی دست نزنه.

for i in range(n):: یک حلقه می‌سازه که از خانه 0 تا n-1 می‌رود.

result[i][i] = 1: در هر دور حلقه، خانه روی قطر اصلی رو برابر با ۱ قرار می‌ده. این کار تضمین می‌کنه که هر نقطه به خودش وصل بشه.

return result: ماتریس جدید رو که حالا خاصیت بازتابی رو داره، برمی‌گردونه.

۲. بستار تقارنی (Symmetric Closure) ↔️
خاصیت تقارنی یعنی اگر از الف به ب راهی هست، از ب به الف هم راهی باشه.

n = len(m): تعداد سطرها رو پیدا می‌کنه.

result = [row[:] for row in m]: یک کپی از ماتریس اصلی می‌سازه.

for i in range(n): و for j in range(n):: با دو حلقه تودرتو، به تمام خانه‌های ماتریس دسترسی پیدا می‌کنه.

if m[i][j] == 1:: اگر یک فلش از i به j وجود داشت...

result[j][i] = 1: ...کد تضمین می‌کنه که فلش برعکس اون، یعنی از j به i هم وجود داشته باشه.

return result: ماتریس جدید رو که حالا خاصیت تقارنی رو داره، برمی‌گردونه.

۳. بستار ترایایی (Transitive Closure) ➡️➡️➡️
خاصیت ترایایی می‌گه که اگه از الف به ب و از ب به ج راهی هست، باید یک راه مستقیم از الف به ج هم داشته باشیم. برای این کار از الگوریتم وارشال استفاده می‌شه.

n = len(m) و result = [row[:] for row in m]: مثل توابع قبلی، ابعاد رو پیدا کرده و یک کپی می‌سازه.

for k in range(n):، for i in range(n): و for j in range(n):: سه حلقه تودرتو که قلب این الگوریتم هستند.

if result[i][k] == 1 and result[k][j] == 1:: این شرط جادوی اصلیه! این خط بررسی می‌کنه که آیا مسیری از i به k و از k به j وجود داره؟

result[i][j] = 1: اگر شرط بالا درست باشه، یعنی از i به j یک مسیر دو مرحله‌ای داریم، پس خانه [i, j] رو ۱ می‌کنیم تا نشان دهیم یک راه مستقیم هم وجود داره.

return result: ماتریس نهایی رو برمی‌گردونه که بستار ترایایی رو داره.

بخش نهایی: نمایش نتایج 💻
print(...): در این بخش، برنامه تمام توابعی رو که تعریف کردیم، فراخوانی می‌کنه و نتایج رو به ترتیب چاپ می‌کنه تا بتونی ماتریس اصلی و ماتریس‌های بستار رو ببینی. این بخش کدها رو به ترتیب و با عنوان‌های مشخص اجرا می‌کنه.