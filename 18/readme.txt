سلام! 😃 الگوریتم دایکسترا مثل این می‌مونه که بخواهی از یک شهر به شهر دیگه سفر کنی و دنبال کوتاه‌ترین مسیر بگردی. این الگوریتم هم دقیقاً همین کار رو در یک نقشه (که بهش می‌گیم گراف) انجام می‌ده.

الگوریتم دایکسترا به زبان ساده
فکر کن می‌خوای از خانه به مدرسه‌ات برسی. تو می‌دونی که هر خیابان چه مسافتی داره. کاری که دایکسترا انجام می‌ده اینه:

اول، به همه خیابان‌هایی که از خانه‌ات شروع می‌شن نگاه می‌کنه و مسافت اون‌ها رو یادداشت می‌کنه.

کوتاه‌ترین خیابان رو پیدا می‌کنه و از اونجا شروع می‌کنه به راه رفتن.

حالا از سر اون خیابان جدید، به همه خیابان‌های اطراف نگاه می‌کنه.

اگر یک راه جدید پیدا کرد که از راه‌های قبلی کوتاه‌تر بود، اون راه جدید رو به عنوان "کوتاه‌ترین راه تا الان" علامت می‌زنه.

این کار رو همین‌طور ادامه می‌ده تا به مقصد برسه و کوتاه‌ترین مسیر رو پیدا کنه.

کد پایتون 🪄
این کد، الگوریتم دایکسترا رو برای پیدا کردن کوتاه‌ترین مسیر بین دو نقطه پیاده‌سازی می‌کنه. ما از یک دیکشنری برای ساختن نقشه (گراف) استفاده می‌کنیم که کار رو خیلی راحت‌تر می‌کنه.

Python

# نقشه ما (گراف)
# هر کلید یک نقطه است، و هر مقدار یک دیکشنری دیگر است
# که نقاط مجاور و فاصله آن‌ها را نشان می‌دهد.
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

# تابع جادویی ما برای پیدا کردن کوتاه‌ترین مسیر
def dijkstra(graph, start, end):
    # اینجا یک جعبه برای نگهداری کوتاه‌ترین مسافت‌ها می‌سازیم
    # اول به همه جا می‌گیم که مسافتشون بی‌نهایت (خیلی زیاد) است
    distances = {node: float('infinity') for node in graph}
    distances[start] = 0  # مسافت از نقطه شروع به خودش صفره
    
    # یک لیست خالی برای نقاطی که از آن‌ها بازدید کردیم
    visited = []
    
    # یک دیکشنری برای نگهداری مسیر
    path = {}

    while len(visited) < len(graph):
        # پیدا کردن نزدیک‌ترین نقطه از میان نقاطی که هنوز نرفتیم
        min_distance = float('infinity')
        closest_node = None
        for node in graph:
            if node not in visited and distances[node] < min_distance:
                min_distance = distances[node]
                closest_node = node
        
        # اگر نزدیک‌ترین نقطه پیدا نشد، از حلقه خارج می‌شیم
        if closest_node is None:
            break
            
        # این نقطه رو به لیست نقاطی که دیدیم اضافه می‌کنیم
        visited.append(closest_node)
        
        # حالا به همسایه‌های این نقطه نگاه می‌کنیم
        for neighbor, weight in graph[closest_node].items():
            if distances[closest_node] + weight < distances[neighbor]:
                # اگر مسیر جدید کوتاه‌تر بود، اون رو جایگزین می‌کنیم
                distances[neighbor] = distances[closest_node] + weight
                path[neighbor] = closest_node # و مسیر رو هم یادداشت می‌کنیم

    return distances, path

# حالا می‌خواهیم مسیر رو از "A" به "D" پیدا کنیم
distances, path = dijkstra(graph, 'A', 'D')

# چاپ کردن نتیجه
print("کوتاه ترین مسافت از A به D:", distances['D'])

# حالا مسیر رو از آخر به اول پیدا می‌کنیم
route = []
current_node = 'D'
while current_node is not None:
    route.insert(0, current_node)
    current_node = path.get(current_node, None)

print("مسیر:", ' -> '.join(route))
توضیح کد 📖
تعریف گراف:

graph = {...}: ما نقشه رو با استفاده از دیکشنری (مثل یک دفترچه تلفن) درست کردیم. هر کلید یک نقطه (مثلاً A) است و مقدار آن یک دیکشنری دیگر است که نشان می‌دهد از A به کجاها می‌توان رفت و فاصله هر مسیر چقدر است.

تابع dijkstra:

distances: یک دیکشنری است که در ابتدا، مسافت هر نقطه از نقطه شروع رو "بی‌نهایت" قرار می‌ده. این مثل اینه که اول سفر، نمی‌دونیم تا کجا چقدر راهه.

distances[start] = 0: مسافت از نقطه شروع به خودش صفره، چون اصلاً راه نرفتیم.

visited: این یک لیست خالی است که هر نقطه‌ای رو که رفتیم، در آن می‌ذاریم.

path: یک دیکشنری خالی برای ذخیره مسیر درست می‌کنیم.

حلقه اصلی:

while len(visited) < len(graph): این حلقه تا وقتی که همه نقاط رو نرفتیم، ادامه پیدا می‌کنه.

در هر دور حلقه، ما دنبال نزدیک‌ترین نقطه (با کمترین مسافت) می‌گردیم که هنوز ندیدیم.

بعد از پیدا کردن نزدیک‌ترین نقطه، اون رو به لیست visited اضافه می‌کنیم.

با حلقه for بعدی، به تمام همسایه‌های اون نقطه نگاه می‌کنیم و مسافت جدید رو حساب می‌کنیم. اگر مسافت جدید کوتاه‌تر از مسافت قبلی بود، اون رو جایگزین می‌کنیم.

چاپ نتیجه:

بعد از اینکه تابع کارش رو تموم کرد، ما مسافت نهایی تا مقصد (distances['D']) و همچنین با استفاده از دیکشنری path، مسیری که رفتیم رو به صورت برعکس پیدا و چاپ می‌کنیم.